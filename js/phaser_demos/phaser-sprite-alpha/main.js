
var Blocks = {};

// setup the game.data object
Blocks.setup = function (game) {

    game.data = {

        maxEnemies: 5,
        enemies: game.add.group(),
        score: 0

    };

};

// setup a data object for a given sprite
Blocks.setSpriteDataObject = function (game, sprite) {

    var data = sprite.data;

    data.i = 0;
    data.i_max = 50;
    data.sprite = sprite;

    data.dx = Math.random() * 2 + 1;
    data.dy = Math.random() * 2 + 1;

    // to be called on each frame tick
    data.tick = function (game) {

        if (this.sprite.alive) {

            // sprites when alive the alpha value will get higher
            // if it is closer to the center of the canvas

            var d = Phaser.Math.distance(this.sprite.x + 16, this.sprite.y + 16, game.world.centerX, game.world.centerY);
            d = Phaser.Math.clamp(d, 0, 100);

            this.sprite.alpha = 1 - 0.75 * (d / 100);

        } else {

            // if dead a sprites alpha starts at 1
            // and goes down two zero
            this.i += 1;
            this.sprite.alpha = 1 - this.i / this.i_max;

            // destroy the sprite completely
            // when done
            if (this.i >= this.i_max) {
                this.sprite.destroy();
            }

        }

    };

    // what to do when killed
    data.onDeath = function () {

        this.dx = 0;
        this.dy = 0;
        this.sprite.exists = true;
        this.sprite.frame = 1;
        this.i = 0;

    };

};

// spawn another enemy
Blocks.spawn = function (game) {

    var data = this.game.data;

    if (data.enemies.length < data.maxEnemies) {

        // create a new enemy
        var enemy = data.enemies.create(-32, -32, 'sheet-block');

        // set health
        enemy.health = 1;

        // setup a data object for the sprite
        Blocks.setSpriteDataObject(game, enemy);

        // events
        enemy.events.onKilled.add(function (enemy) {
            enemy.data.onDeath();
        });
        enemy.inputEnabled = true;
        enemy.events.onInputDown.add(function (enemy) {
            enemy.damage(1);
        });

    }

};

var game = new Phaser.Game(320, 240, Phaser.AUTO, 'gamearea');

game.state.add('boot', {

    create: function () {

        // sprite sheet generated by canvas
        var canvas = document.createElement('canvas'),
        ctx = canvas.getContext('2d');
        canvas.width = 64;
        canvas.height = 32;

        // blue frame
        ctx.fillStyle = 'blue';
        ctx.strokeStyle = 'white';
        ctx.fillRect(0, 0, 32, 32);
        ctx.strokeRect(0, 0, 32, 32);

        // red frame
        ctx.fillStyle = 'red';
        ctx.fillRect(32, 0, 32, 32);

        game.cache.addSpriteSheet('sheet-block', null, canvas, 32, 32, 2, 0, 0);

        // scrolling
        game.scale.compatibility.scrollTo = false;
        game.scale.pageAlignHorizontally = true;
        game.scale.scaleMode = Phaser.ScaleManager.SHOW_ALL;
        game.scale.width = document.getElementById(game.parent).scrollWidth;
        game.scale.height = document.getElementById(game.parent).scrollHeight;

        // start demo, and do not clear the world
        game.state.start('demo');

    }

});

game.state.add('demo', {

    create: function () {

        Blocks.setup(game);

        // spawn loop
        game.time.events.loop(1000, Blocks.spawn, this);

        var text = game.add.text(5, 5, '', {
                fill: 'white'
            });
        text.name = 'disp';

    },

    update: function () {

        var data = this.game.data,
        game = this.game;

        data.enemies.forEach(function (enemy) {

            enemy.x = Phaser.Math.wrap(enemy.x += enemy.data.dx, -32, game.world.width + 32);
            enemy.y = Phaser.Math.wrap(enemy.y += enemy.data.dy, -32, game.world.height + 32);

            enemy.data.tick(game);

        });

    }

});

game.state.start('boot');
